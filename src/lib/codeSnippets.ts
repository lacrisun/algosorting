export type AlgorithmName = 'Bubble Sort' | 'Insertion Sort' | 'Selection Sort' | 'Shell Sort' | 'Quick Sort' | 'Merge Sort';
export type LanguageName = 'Python' | 'C++' | 'JavaScript' | 'C#' | 'C';

export interface CodeLine {
  text: string;
  conceptualStepId?: number;
}

export const codeSnippets: Record<AlgorithmName, Partial<Record<LanguageName, CodeLine[]>>> = {
  'Bubble Sort': {
    'Python': [
      { text: "def bubble_sort(arr):", conceptualStepId: 1 },
      { text: "  n = len(arr)" },
      { text: "  for i in range(n - 1):", conceptualStepId: 2 },
      { text: "    swapped = False" },
      { text: "    for j in range(n - i - 1):", conceptualStepId: 3 },
      { text: "      if arr[j] > arr[j+1]:", conceptualStepId: 4 },
      { text: "        arr[j], arr[j+1] = arr[j+1], arr[j]", conceptualStepId: 5 },
      { text: "        swapped = True" },
      { text: "    # Element arr[n-1-i] is sorted", conceptualStepId: 6 }, // Placeholder text, actual logic is in TS
      { text: "    if not swapped:", conceptualStepId: 7 },
      { text: "      break" },
      { text: "  return arr", conceptualStepId: 8 },
    ],
    'C++': [
      { text: "void bubbleSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  bool swapped;" },
      { text: "  for (int i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    swapped = false;" },
      { text: "    for (int j = 0; j < n - i - 1; j++) {", conceptualStepId: 3 },
      { text: "      if (arr[j] > arr[j+1]) {", conceptualStepId: 4 },
      { text: "        std::swap(arr[j], arr[j+1]);", conceptualStepId: 5 },
      { text: "        swapped = true;" },
      { text: "      }" },
      { text: "    }" },
      { text: "    // Element arr[n-1-i] is sorted", conceptualStepId: 6 }, // Placeholder text
      { text: "    if (!swapped) {", conceptualStepId: 7 },
      { text: "      break;" },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    'JavaScript': [
      { text: "function bubbleSort(arr) {", conceptualStepId: 1 },
      { text: "  let n = arr.length;" },
      { text: "  let swapped;" },
      { text: "  for (let i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    swapped = false;" },
      { text: "    for (let j = 0; j < n - i - 1; j++) {", conceptualStepId: 3 },
      { text: "      if (arr[j] > arr[j+1]) {", conceptualStepId: 4 },
      { text: "        [arr[j], arr[j+1]] = [arr[j+1], arr[j]];", conceptualStepId: 5 },
      { text: "        swapped = true;" },
      { text: "      }" },
      { text: "    }" },
      { text: "    if (!swapped) {", conceptualStepId: 7 },
      { text: "      break;" },
      { text: "    }" },
      { text: "  }" },
      { text: "  return arr;", conceptualStepId: 8 },
    ],
    'C#': [
      { text: "public static void BubbleSort(int[] arr) {", conceptualStepId: 1 },
      { text: "  int n = arr.Length;" },
      { text: "  bool swapped;" },
      { text: "  for (int i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    swapped = false;" },
      { text: "    for (int j = 0; j < n - i - 1; j++) {", conceptualStepId: 3 },
      { text: "      if (arr[j] > arr[j+1]) {", conceptualStepId: 4 },
      { text: "        int temp = arr[j];" },
      { text: "        arr[j] = arr[j+1];" },
      { text: "        arr[j+1] = temp;", conceptualStepId: 5 },
      { text: "        swapped = true;" },
      { text: "      }" },
      { text: "    }" },
      { text: "    if (!swapped) {", conceptualStepId: 7 },
      { text: "      break;" },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    'C': [
      { text: "void bubbleSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int i, j, temp;" },
      { text: "  int swapped;" },
      { text: "  for (i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    swapped = 0;" },
      { text: "    for (j = 0; j < n - i - 1; j++) {", conceptualStepId: 3 },
      { text: "      if (arr[j] > arr[j+1]) {", conceptualStepId: 4 },
      { text: "        temp = arr[j];" },
      { text: "        arr[j] = arr[j+1];" },
      { text: "        arr[j+1] = temp;", conceptualStepId: 5 },
      { text: "        swapped = 1;" },
      { text: "      }" },
      { text: "    }" },
      { text: "    if (swapped == 0) {", conceptualStepId: 7 },
      { text: "      break;" },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
  },
  'Insertion Sort': {
    'Python': [
      { text: "def insertion_sort(arr):", conceptualStepId: 1 },
      { text: "  n = len(arr)" },
      { text: "  # Mark arr[0] as sorted", conceptualStepId: 2 },
      { text: "  for i in range(1, n):", conceptualStepId: 3 },
      { text: "    current = arr[i]", conceptualStepId: 4 },
      { text: "    j = i - 1" },
      { text: "    while j >= 0 and arr[j] > current:", conceptualStepId: 5 },
      { text: "      arr[j+1] = arr[j]", conceptualStepId: 6 },
      { text: "      j -= 1" },
      { text: "    arr[j+1] = current", conceptualStepId: 7 },
      { text: "  return arr", conceptualStepId: 8 },
    ],
    'C++': [
      { text: "void insertionSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int i, key, j;" },
      { text: "  for (i = 1; i < n; i++) {", conceptualStepId: 3 },
      { text: "    key = arr[i];", conceptualStepId: 4 },
      { text: "    j = i - 1;" },
      { text: "    while (j >= 0 && arr[j] > key) {", conceptualStepId: 5 },
      { text: "      arr[j+1] = arr[j];", conceptualStepId: 6 },
      { text: "      j = j - 1;" },
      { text: "    }" },
      { text: "    arr[j+1] = key;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    'JavaScript': [
      { text: "function insertionSort(arr) {", conceptualStepId: 1 },
      { text: "  let n = arr.length;" },
      { text: "  for (let i = 1; i < n; i++) {", conceptualStepId: 3 },
      { text: "    let current = arr[i];", conceptualStepId: 4 },
      { text: "    let j = i - 1;" },
      { text: "    while (j >= 0 && arr[j] > current) {", conceptualStepId: 5 },
      { text: "      arr[j+1] = arr[j];", conceptualStepId: 6 },
      { text: "      j--;" },
      { text: "    }" },
      { text: "    arr[j+1] = current;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "  return arr;", conceptualStepId: 8 },
    ],
    'C#': [
      { text: "public static void InsertionSort(int[] arr) {", conceptualStepId: 1 },
      { text: "  int n = arr.Length;" },
      { text: "  for (int i = 1; i < n; ++i) {", conceptualStepId: 3 },
      { text: "    int key = arr[i];", conceptualStepId: 4 },
      { text: "    int j = i - 1;" },
      { text: "    while (j >= 0 && arr[j] > key) {", conceptualStepId: 5 },
      { text: "      arr[j+1] = arr[j];", conceptualStepId: 6 },
      { text: "      j = j - 1;" },
      { text: "    }" },
      { text: "    arr[j+1] = key;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    'C': [
      { text: "void insertionSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int i, key, j;" },
      { text: "  for (i = 1; i < n; i++) {", conceptualStepId: 3 },
      { text: "    key = arr[i];", conceptualStepId: 4 },
      { text: "    j = i - 1;" },
      { text: "    while (j >= 0 && arr[j] > key) {", conceptualStepId: 5 },
      { text: "      arr[j+1] = arr[j];", conceptualStepId: 6 },
      { text: "      j = j - 1;" },
      { text: "    }" },
      { text: "    arr[j+1] = key;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
  },
  "Selection Sort": {
    "Python": [
      { text: "def selection_sort(arr):", conceptualStepId: 1 },
      { text: "  n = len(arr)" },
      { text: "  for i in range(n - 1):", conceptualStepId: 2 },
      { text: "    min_idx = i", conceptualStepId: 3 },
      { text: "    for j in range(i + 1, n):", conceptualStepId: 4 },
      { text: "      if arr[j] < arr[min_idx]:", conceptualStepId: 5 },
      { text: "        min_idx = j", conceptualStepId: 6 },
      { text: "    arr[i], arr[min_idx] = arr[min_idx], arr[i]", conceptualStepId: 7 },
      { text: "  return arr", conceptualStepId: 8 },
    ],
    "C++": [
      { text: "void selectionSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int i, j, min_idx;" },
      { text: "  for (i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    min_idx = i;", conceptualStepId: 3 },
      { text: "    for (j = i + 1; j < n; j++) {", conceptualStepId: 4 },
      { text: "      if (arr[j] < arr[min_idx]) {", conceptualStepId: 5 },
      { text: "        min_idx = j;", conceptualStepId: 6 },
      { text: "      }" },
      { text: "    }" },
      { text: "    std::swap(arr[min_idx], arr[i]);", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    "JavaScript": [
      { text: "function selectionSort(arr) {", conceptualStepId: 1 },
      { text: "  let n = arr.length;" },
      { text: "  for (let i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    let minIdx = i;", conceptualStepId: 3 },
      { text: "    for (let j = i + 1; j < n; j++) {", conceptualStepId: 4 },
      { text: "      if (arr[j] < arr[minIdx]) {", conceptualStepId: 5 },
      { text: "        minIdx = j;", conceptualStepId: 6 },
      { text: "      }" },
      { text: "    }" },
      { text: "    [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];", conceptualStepId: 7 },
      { text: "  }" },
      { text: "  return arr;", conceptualStepId: 8 },
    ],
    "C#": [
      { text: "public static void SelectionSort(int[] arr) {", conceptualStepId: 1 },
      { text: "  int n = arr.Length;" },
      { text: "  for (int i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    int minIdx = i;", conceptualStepId: 3 },
      { text: "    for (int j = i + 1; j < n; j++) {", conceptualStepId: 4 },
      { text: "      if (arr[j] < arr[minIdx]) {", conceptualStepId: 5 },
      { text: "        minIdx = j;", conceptualStepId: 6 },
      { text: "      }" },
      { text: "    }" },
      { text: "    int temp = arr[minIdx];" },
      { text: "    arr[minIdx] = arr[i];" },
      { text: "    arr[i] = temp;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
    "C": [
      { text: "void selectionSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int i, j, min_idx, temp;" },
      { text: "  for (i = 0; i < n - 1; i++) {", conceptualStepId: 2 },
      { text: "    min_idx = i;", conceptualStepId: 3 },
      { text: "    for (j = i + 1; j < n; j++) {", conceptualStepId: 4 },
      { text: "      if (arr[j] < arr[min_idx]) {", conceptualStepId: 5 },
      { text: "        min_idx = j;", conceptualStepId: 6 },
      { text: "      }" },
      { text: "    }" },
      { text: "    temp = arr[min_idx];" },
      { text: "    arr[min_idx] = arr[i];" },
      { text: "    arr[i] = temp;", conceptualStepId: 7 },
      { text: "  }" },
      { text: "}", conceptualStepId: 8 },
    ],
  },
  "Shell Sort": {
    "Python": [
      { text: "def shell_sort(arr):", conceptualStepId: 1 },
      { text: "  n = len(arr)" },
      { text: "  gap = n // 2", conceptualStepId: 2 },
      { text: "  while gap > 0:", conceptualStepId: 3 },
      { text: "    for i in range(gap, n):", conceptualStepId: 4 },
      { text: "      temp = arr[i]", conceptualStepId: 5 },
      { text: "      j = i" },
      { text: "      while j >= gap and arr[j - gap] > temp:", conceptualStepId: 6 },
      { text: "        arr[j] = arr[j - gap]", conceptualStepId: 7 },
      { text: "        j -= gap" },
      { text: "      arr[j] = temp", conceptualStepId: 8 },
      { text: "    gap //= 2", conceptualStepId: 9 },
      { text: "  return arr", conceptualStepId: 10 },
    ],
    "C++": [
      { text: "void shellSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  for (int gap = n / 2; gap > 0; gap /= 2) {", conceptualStepId: 3 },
      { text: "    for (int i = gap; i < n; i += 1) {", conceptualStepId: 4 },
      { text: "      int temp = arr[i];", conceptualStepId: 5 },
      { text: "      int j;" },
      { text: "      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {", conceptualStepId: 6 },
      { text: "        arr[j] = arr[j - gap];", conceptualStepId: 7 },
      { text: "      }" },
      { text: "      arr[j] = temp;", conceptualStepId: 8 },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 10 },
    ],
    "JavaScript": [
      { text: "function shellSort(arr) {", conceptualStepId: 1 },
      { text: "  let n = arr.length;" },
      { text: "  for (let gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {", conceptualStepId: 3 },
      { text: "    for (let i = gap; i < n; i++) {", conceptualStepId: 4 },
      { text: "      let temp = arr[i];", conceptualStepId: 5 },
      { text: "      let j;" },
      { text: "      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {", conceptualStepId: 6 },
      { text: "        arr[j] = arr[j - gap];", conceptualStepId: 7 },
      { text: "      }" },
      { text: "      arr[j] = temp;", conceptualStepId: 8 },
      { text: "    }" },
      { text: "  }" },
      { text: "  return arr;", conceptualStepId: 10 },
    ],
    "C#": [
      { text: "public static void ShellSort(int[] arr) {", conceptualStepId: 1 },
      { text: "  int n = arr.Length;" },
      { text: "  for (int gap = n / 2; gap > 0; gap /= 2) {", conceptualStepId: 3 },
      { text: "    for (int i = gap; i < n; i += 1) {", conceptualStepId: 4 },
      { text: "      int temp = arr[i];", conceptualStepId: 5 },
      { text: "      int j;" },
      { text: "      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {", conceptualStepId: 6 },
      { text: "        arr[j] = arr[j - gap];", conceptualStepId: 7 },
      { text: "      }" },
      { text: "      arr[j] = temp;", conceptualStepId: 8 },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 10 },
    ],
    "C": [
      { text: "void shellSort(int arr[], int n) {", conceptualStepId: 1 },
      { text: "  int gap, i, j, temp;" },
      { text: "  for (gap = n / 2; gap > 0; gap /= 2) {", conceptualStepId: 3 },
      { text: "    for (i = gap; i < n; i++) {", conceptualStepId: 4 },
      { text: "      temp = arr[i];", conceptualStepId: 5 },
      { text: "      for (j = i; j >= gap && arr[j - gap] > temp; j -= gap) {", conceptualStepId: 6 },
      { text: "        arr[j] = arr[j - gap];", conceptualStepId: 7 },
      { text: "      }" },
      { text: "      arr[j] = temp;", conceptualStepId: 8 },
      { text: "    }" },
      { text: "  }" },
      { text: "}", conceptualStepId: 10 },
    ],
  },
  "Quick Sort": {
    "Python": [
      { text: "def quick_sort(arr, low, high):", conceptualStepId: 1 },
      { text: "  if low < high:", conceptualStepId: 9 },
      { text: "    pi = partition(arr, low, high)", conceptualStepId: 10 },
      { text: "    quick_sort(arr, low, pi - 1)" },
      { text: "    quick_sort(arr, pi + 1, high)" },
      { text: "def partition(arr, low, high):" },
      { text: "  pivot = arr[high]", conceptualStepId: 11 },
      { text: "  i = low - 1" },
      { text: "  for j in range(low, high):", conceptualStepId: 12 },
      { text: "    if arr[j] < pivot:", conceptualStepId: 13 },
      { text: "      i += 1" },
      { text: "      arr[i], arr[j] = arr[j], arr[i]", conceptualStepId: 14 },
      { text: "  arr[i+1], arr[high] = arr[high], arr[i+1]", conceptualStepId: 15 },
      { text: "  return i + 1", conceptualStepId: 16 },
    ],
    "C++": [
      { text: "int partition(int arr[], int low, int high) {", conceptualStepId: 10 },
      { text: "  int pivot = arr[high];", conceptualStepId: 11 },
      { text: "  int i = (low - 1);" },
      { text: "  for (int j = low; j <= high - 1; j++) {", conceptualStepId: 12 },
      { text: "    if (arr[j] < pivot) {", conceptualStepId: 13 },
      { text: "      i++;" },
      { text: "      std::swap(arr[i], arr[j]);", conceptualStepId: 14 },
      { text: "    }" },
      { text: "  }" },
      { text: "  std::swap(arr[i + 1], arr[high]);", conceptualStepId: 15 },
      { text: "  return (i + 1);", conceptualStepId: 16 },
      { text: "}" },
      { text: "void quickSort(int arr[], int low, int high) {", conceptualStepId: 1 },
      { text: "  if (low < high) {", conceptualStepId: 9 },
      { text: "    int pi = partition(arr, low, high);" },
      { text: "    quickSort(arr, low, pi - 1);" },
      { text: "    quickSort(arr, pi + 1, high);" },
      { text: "  }" },
      { text: "}" },
    ],
    "JavaScript": [
      { text: "function partition(arr, low, high) {", conceptualStepId: 10 },
      { text: "  let pivot = arr[high];", conceptualStepId: 11 },
      { text: "  let i = low - 1;" },
      { text: "  for (let j = low; j < high; j++) {", conceptualStepId: 12 },
      { text: "    if (arr[j] < pivot) {", conceptualStepId: 13 },
      { text: "      i++;" },
      { text: "      [arr[i], arr[j]] = [arr[j], arr[i]];", conceptualStepId: 14 },
      { text: "    }" },
      { text: "  }" },
      { text: "  [arr[i+1], arr[high]] = [arr[high], arr[i+1]];", conceptualStepId: 15 },
      { text: "  return i + 1;", conceptualStepId: 16 },
      { text: "}" },
      { text: "function quickSort(arr, low, high) {", conceptualStepId: 1 },
      { text: "  if (low < high) {", conceptualStepId: 9 },
      { text: "    let pi = partition(arr, low, high);" },
      { text: "    quickSort(arr, low, pi - 1);" },
      { text: "    quickSort(arr, pi + 1, high);" },
      { text: "  }" },
      { text: "  return arr;" },
      { text: "}" },
    ],
    "C#": [
      { text: "public static int Partition(int[] arr, int low, int high) {", conceptualStepId: 10 },
      { text: "  int pivot = arr[high];", conceptualStepId: 11 },
      { text: "  int i = (low - 1);" },
      { text: "  for (int j = low; j < high; j++) {", conceptualStepId: 12 },
      { text: "    if (arr[j] < pivot) {", conceptualStepId: 13 },
      { text: "      i++;" },
      { text: "      int temp1 = arr[i];" },
      { text: "      arr[i] = arr[j];" },
      { text: "      arr[j] = temp1;", conceptualStepId: 14 },
      { text: "    }" },
      { text: "  }" },
      { text: "  int temp2 = arr[i + 1];" },
      { text: "  arr[i + 1] = arr[high];" },
      { text: "  arr[high] = temp2;", conceptualStepId: 15 },
      { text: "  return (i + 1);", conceptualStepId: 16 },
      { text: "}" },
      { text: "public static void QuickSort(int[] arr, int low, int high) {", conceptualStepId: 1 },
      { text: "  if (low < high) {", conceptualStepId: 9 },
      { text: "    int pi = Partition(arr, low, high);" },
      { text: "    QuickSort(arr, low, pi - 1);" },
      { text: "    QuickSort(arr, pi + 1, high);" },
      { text: "  }" },
      { text: "}" },
    ],
    "C": [
      { text: "void swap(int* a, int* b) {" },
      { text: "  int t = *a;" },
      { text: "  *a = *b;" },
      { text: "  *b = t;" },
      { text: "}" },
      { text: "int partition (int arr[], int low, int high) {", conceptualStepId: 10 },
      { text: "  int pivot = arr[high];", conceptualStepId: 11 },
      { text: "  int i = (low - 1);" },
      { text: "  for (int j = low; j <= high- 1; j++) {", conceptualStepId: 12 },
      { text: "    if (arr[j] < pivot) {", conceptualStepId: 13 },
      { text: "      i++;" },
      { text: "      swap(&arr[i], &arr[j]);", conceptualStepId: 14 },
      { text: "    }" },
      { text: "  }" },
      { text: "  swap(&arr[i + 1], &arr[high]);", conceptualStepId: 15 },
      { text: "  return (i + 1);", conceptualStepId: 16 },
      { text: "}" },
      { text: "void quickSort(int arr[], int low, int high) {", conceptualStepId: 1 },
      { text: "  if (low < high) {", conceptualStepId: 9 },
      { text: "    int pi = partition(arr, low, high);" },
      { text: "    quickSort(arr, low, pi - 1);" },
      { text: "    quickSort(arr, pi + 1, high);" },
      { text: "  }" },
      { text: "}" },
    ],
  },
  "Merge Sort": {
    "Python": [
      { text: "def merge_sort(arr):", conceptualStepId: 1 },
      { text: "  if len(arr) > 1:" },
      { text: "    mid = len(arr) // 2", conceptualStepId: 19 },
      { text: "    L = arr[:mid]" },
      { text: "    R = arr[mid:]" },
      { text: "    merge_sort(L)" },
      { text: "    merge_sort(R)" },
      { text: "    i = j = k = 0", conceptualStepId: 20 },
      { text: "    while i < len(L) and j < len(R):", conceptualStepId: 21 },
      { text: "      if L[i] < R[j]:", conceptualStepId: 22 },
      { text: "        arr[k] = L[i]" },
      { text: "        i += 1" },
      { text: "      else:", conceptualStepId: 23 },
      { text: "        arr[k] = R[j]" },
      { text: "        j += 1" },
      { text: "      k += 1" },
      { text: "    while i < len(L):", conceptualStepId: 24 },
      { text: "      arr[k] = L[i]" },
      { text: "      i += 1" },
      { text: "      k += 1" },
      { text: "    while j < len(R):", conceptualStepId: 25 },
      { text: "      arr[k] = R[j]" },
      { text: "      j += 1" },
      { text: "      k += 1" },
      { text: "  # Subarray merged", conceptualStepId: 26 },
      { text: "  return arr", conceptualStepId: 27 },
    ],
    "C++": [
      { text: "void merge(int arr[], int l, int m, int r) {", conceptualStepId: 20 },
      { text: "  int n1 = m - l + 1;" },
      { text: "  int n2 = r - m;" },
      { text: "  int L[n1], R[n2];" },
      { text: "  for (int i = 0; i < n1; i++) L[i] = arr[l + i];" },
      { text: "  for (int j = 0; j < n2; j++) R[j] = arr[m + 1 + j];" },
      { text: "  int i = 0, j = 0, k = l;" },
      { text: "  while (i < n1 && j < n2) {", conceptualStepId: 21 },
      { text: "    if (L[i] <= R[j]) {", conceptualStepId: 22 },
      { text: "      arr[k] = L[i]; i++;" },
      { text: "    } else {", conceptualStepId: 23 },
      { text: "      arr[k] = R[j]; j++;" },
      { text: "    }" },
      { text: "    k++;" },
      { text: "  }" },
      { text: "  while (i < n1) {", conceptualStepId: 24 },
      { text: "    arr[k] = L[i]; i++; k++;" },
      { text: "  }" },
      { text: "  while (j < n2) {", conceptualStepId: 25 },
      { text: "    arr[k] = R[j]; j++; k++;" },
      { text: "  }" },
      { text: "}", conceptualStepId: 26 },
      { text: "void mergeSort(int arr[], int l, int r) {", conceptualStepId: 1 },
      { text: "  if (l < r) {", conceptualStepId: 19 },
      { text: "    int m = l + (r - l) / 2;" },
      { text: "    mergeSort(arr, l, m);" },
      { text: "    mergeSort(arr, m + 1, r);" },
      { text: "    merge(arr, l, m, r);" },
      { text: "  }" },
      { text: "}", conceptualStepId: 27 },
    ],
    "JavaScript": [
      { text: "function merge(arr, l, m, r) {", conceptualStepId: 20 },
      { text: "  let n1 = m - l + 1;" },
      { text: "  let n2 = r - m;" },
      { text: "  let L = new Array(n1);" },
      { text: "  let R = new Array(n2);" },
      { text: "  for (let i = 0; i < n1; i++) L[i] = arr[l + i];" },
      { text: "  for (let j = 0; j < n2; j++) R[j] = arr[m + 1 + j];" },
      { text: "  let i = 0, j = 0, k = l;" },
      { text: "  while (i < n1 && j < n2) {", conceptualStepId: 21 },
      { text: "    if (L[i] <= R[j]) {", conceptualStepId: 22 },
      { text: "      arr[k] = L[i]; i++;" },
      { text: "    } else {", conceptualStepId: 23 },
      { text: "      arr[k] = R[j]; j++;" },
      { text: "    }" },
      { text: "    k++;" },
      { text: "  }" },
      { text: "  while (i < n1) {", conceptualStepId: 24 },
      { text: "    arr[k] = L[i]; i++; k++;" },
      { text: "  }" },
      { text: "  while (j < n2) {", conceptualStepId: 25 },
      { text: "    arr[k] = R[j]; j++; k++;" },
      { text: "  }" },
      { text: "}", conceptualStepId: 26 },
      { text: "function mergeSort(arr, l, r) {", conceptualStepId: 1 },
      { text: "  if (l < r) {", conceptualStepId: 19 },
      { text: "    let m = l + Math.floor((r - l) / 2);" },
      { text: "    mergeSort(arr, l, m);" },
      { text: "    mergeSort(arr, m + 1, r);" },
      { text: "    merge(arr, l, m, r);" },
      { text: "  }" },
      { text: "  return arr;" , conceptualStepId: 27 },
      { text: "}" },
    ],
    "C#": [
      { text: "public static void Merge(int[] arr, int l, int m, int r) {", conceptualStepId: 20 },
      { text: "  int n1 = m - l + 1;" },
      { text: "  int n2 = r - m;" },
      { text: "  int[] L = new int[n1];" },
      { text: "  int[] R = new int[n2];" },
      { text: "  for (int i = 0; i < n1; ++i) L[i] = arr[l + i];" },
      { text: "  for (int j = 0; j < n2; ++j) R[j] = arr[m + 1 + j];" },
      { text: "  int k = l; int idx1 = 0; int idx2 = 0;" },
      { text: "  while (idx1 < n1 && idx2 < n2) {", conceptualStepId: 21 },
      { text: "    if (L[idx1] <= R[idx2]) {", conceptualStepId: 22 },
      { text: "      arr[k] = L[idx1]; idx1++;" },
      { text: "    } else {", conceptualStepId: 23 },
      { text: "      arr[k] = R[idx2]; idx2++;" },
      { text: "    }" },
      { text: "    k++;" },
      { text: "  }" },
      { text: "  while (idx1 < n1) {", conceptualStepId: 24 },
      { text: "    arr[k] = L[idx1]; idx1++; k++;" },
      { text: "  }" },
      { text: "  while (idx2 < n2) {", conceptualStepId: 25 },
      { text: "    arr[k] = R[idx2]; idx2++; k++;" },
      { text: "  }" },
      { text: "}", conceptualStepId: 26 },
      { text: "public static void MergeSort(int[] arr, int l, int r) {", conceptualStepId: 1 },
      { text: "  if (l < r) {", conceptualStepId: 19 },
      { text: "    int m = l + (r - l) / 2;" },
      { text: "    MergeSort(arr, l, m);" },
      { text: "    MergeSort(arr, m + 1, r);" },
      { text: "    Merge(arr, l, m, r);" },
      { text: "  }" },
      { text: "}", conceptualStepId: 27 },
    ],
    "C": [
      { text: "void merge(int arr[], int l, int m, int r) {", conceptualStepId: 20 },
      { text: "  int i, j, k;" },
      { text: "  int n1 = m - l + 1;" },
      { text: "  int n2 = r - m;" },
      { text: "  int L[n1], R[n2];" },
      { text: "  for (i = 0; i < n1; i++) L[i] = arr[l + i];" },
      { text: "  for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j];" },
      { text: "  i = 0; j = 0; k = l;" },
      { text: "  while (i < n1 && j < n2) {", conceptualStepId: 21 },
      { text: "    if (L[i] <= R[j]) {", conceptualStepId: 22 },
      { text: "      arr[k] = L[i]; i++;" },
      { text: "    } else {", conceptualStepId: 23 },
      { text: "      arr[k] = R[j]; j++;" },
      { text: "    }" },
      { text: "    k++;" },
      { text: "  }" },
      { text: "  while (i < n1) {", conceptualStepId: 24 },
      { text: "    arr[k] = L[i]; i++; k++;" },
      { text: "  }" },
      { text: "  while (j < n2) {", conceptualStepId: 25 },
      { text: "    arr[k] = R[j]; j++; k++;" },
      { text: "  }" },
      { text: "}", conceptualStepId: 26 },
      { text: "void mergeSort(int arr[], int l, int r) {", conceptualStepId: 1 },
      { text: "  if (l < r) {", conceptualStepId: 19 },
      { text: "    int m = l + (r - l) / 2;" },
      { text: "    mergeSort(arr, l, m);" },
      { text: "    mergeSort(arr, m + 1, r);" },
      { text: "    merge(arr, l, m, r);" },
      { text: "  }" },
      { text: "}", conceptualStepId: 27 },
    ],
  },
};

